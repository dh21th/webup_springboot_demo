package com.webup.soa.yunshang.utils;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.SecretKey;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.io.UnsupportedEncodingException;import java.util.Arrays;/** * 使用AES算法对文件或者字符串进行加密 * @author kbjf_jinyuefei * */public class AESUtil {	//	private static final Log log = LogFactory.getLog(AESUtil.class);		/**	 * AES加密	 * 	 * @param merKey	 *            密钥信息	 * @param content	 *            待加密信息	 */	public static byte[] encodeAES(String merKey, byte[] content) throws Exception {		byte[] key = merKey.getBytes("GBK");		// 不是16的倍数的，补足		int base = 16;		if (key.length % base != 0) {			int groups = key.length / base + (key.length % base != 0 ? 1 : 0);			byte[] temp = new byte[groups * base];			Arrays.fill(temp, (byte) 0);			System.arraycopy(key, 0, temp, 0, key.length);			key = temp;		}		SecretKey secretKey = new SecretKeySpec(key, "AES");		IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0,				0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");		cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);		byte[] tgtBytes = cipher.doFinal(content);System.err.println("数组："+tgtBytes);		return tgtBytes;	}	/**	 * AES解密	 * 	 * @param merKey	 *            密钥信息	 * @param content	 *            待加密信息	 * @return	 * @throws Exception	 */	public static byte[] decodeAES(String merKey, byte[] content) throws Exception {		byte[] key = merKey.getBytes("GBK");		// 不是16的倍数的，补足		int base = 16;		if (key.length % base != 0) {			int groups = key.length / base + (key.length % base != 0 ? 1 : 0);			byte[] temp = new byte[groups * base];			Arrays.fill(temp, (byte) 0);			System.arraycopy(key, 0, temp, 0, key.length);			key = temp;		}		SecretKey secretKey = new SecretKeySpec(key, "AES");		IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0,				0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");		cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);		byte[] tgtBytes = cipher.doFinal(content);//		System.err.println("数组"+tgtBytes);		return tgtBytes;	}	/**	 * 将二进制转换成16进制	 * 	 * @param buf	 * @return	 */	public static String parseByte2HexStr(byte buf[]) {		StringBuffer sb = new StringBuffer();		for (int i = 0; i < buf.length; i++) {			String hex = Integer.toHexString(buf[i] & 0xFF);			if (hex.length() == 1) {				hex = '0' + hex;			}			sb.append(hex.toUpperCase());		}		return sb.toString();	}	/**	 * 将16进制转换为二进制	 * 	 * @method parseHexStr2Byte	 * @param hexStr	 */	public static byte[] parseHexStr2Byte(String hexStr) {		if (hexStr.length() < 1)			return null;		byte[] result = new byte[hexStr.length() / 2];		for (int i = 0; i < hexStr.length() / 2; i++) {			int high = Integer.parseInt(hexStr.substring(i * 2, i * 2 + 1), 16);			int low = Integer.parseInt(hexStr.substring(i * 2 + 1, i * 2 + 2),					16);			result[i] = (byte) (high * 16 + low);		}		return result;	}	/**	 * 将字符串直接加密并转换成16进制	 * @param key	 * @param content	 * @return	 * @throws Exception	 */	public static String encodeAES2HexStr(String key, String content){		String str = null;		try {			byte[] encryptResult = encodeAES(key, content.getBytes("GBK"));			str = parseByte2HexStr(encryptResult);		} catch (UnsupportedEncodingException e) {//			log.error("编码转换出现异常！");//			throw new AppException(ErrorCode.EMG10012);		} catch (Exception e) {//			log.error("数据加密失败！");//			throw new AppException(ErrorCode.EMG10012);		}// 加密		return str;	}	/**	 * 将加密字符串转换成二进制并解密	 * @param key	 * @param content	 * @return	 * @throws Exception	 */	public static String decodeAES2Byte(String key, String content){		String str = null;		try {			byte[] decryptFrom = parseHexStr2Byte(content);			byte[] decryptResult = decodeAES(key, decryptFrom);			str = new String(decryptResult);		} catch (Exception e) {//			log.error("数据解密失败！");//			throw new AppException(ErrorCode.EMG10013);		}		return str;	}	/**	 * 随机生成密钥	 */	public static String getKey(){				String key = null;		try {			KeyGenerator keyGen = KeyGenerator.getInstance("AES");			keyGen.init(128);			SecretKey sk = keyGen.generateKey();			byte[] b = sk.getEncoded();			key = parseByte2HexStr(b);		} catch (Exception e) {//			log.error("密钥生成失败");//			throw new AppException(ErrorCode.EMG10014);		}		return key.substring(0, 16);	}	public static void main(String[] args) throws Exception {		//加密密钥		String key = "815C91DE18D3F308";		String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><DOCUMENT> <TITLE>1001</TITLE>  <HEAD>  <TRANSCODE>B1001</TRANSCODE>   <MSGID>MSGID-20171108-154642739</MSGID>  <ORGNLMSGID>ORGNLMSGID-20171107-154642738</ORGNLMSGID>  <SESSIONNO>SESSIONNO-20171107-154642738</SESSIONNO>  <SENDDATE>20171107</SENDDATE>  <SENDTIME>154642</SENDTIME>  <ERRCODE></ERRCODE>  <ERRMSG></ERRMSG>  </HEAD>  <BODY>   <SUPPLIER_IDNO>20170113015651</SUPPLIER_IDNO> <CORE_IDNO>9022276632656001</CORE_IDNO> <PAGE_SIZE>1</PAGE_SIZE> <CURRENT_PAGE>1</CURRENT_PAGE>  </BODY></DOCUMENT>";		String str="<?XML version=\"1.0\" encoding=\"UTF-8\"?>" +	            "<DOCUMENT>" +	            "<TITLE>1001<TITLE>" +	            "<HEAD>" +	            "</HEAD>" +	            "<BODY>" +	            "</BODY>" +	           "</DOCUMENT>";		//		System.err.println(getKey());		System.out.println("加密后：" + encodeAES2HexStr(key, str));//		String openxml = AESUtil.decodeAES2Byte(key, "EA343000697896A1332C59D7D81BD27235B7F7BA229C549059F737EBC510485FAE812ACC96A39D8933F5645B81F9B3EA80685B97454FDD11F93BC606148CD9A7509641347988D4EADF34703CA3F3E8974625EC4346A2458823F6B1039942D951CB7BE9A4A5A62FACA4C07708F20E0FAF");//		System.out.println("解密后：" + openxml);			}}